import os
import scipy
import numpy as np
import pandas as pd
import cvxpy as cp

from numpy.random import default_rng
seed = 1024
np.random.seed(seed)
rng = default_rng(seed = seed)

# 1. 第1问
# 1.1 生成数据
days = 10          # 取过去两周作为总周期
num_industry = 40   # 总行业数
num_stock = 3000    # 总股票数
industries = np.arange(num_industry)
times = np.arange(0, days)
# 假设所有股票的个体回报独立同分布
mu = 0.05
sigma = 10
stock_return = rng.normal(mu, sigma, size = (num_stock, days))
# 假设所有的行业回报独立同分布
mu = 0.05
sigma = 5
industry_return = rng.normal(mu, sigma, size = (num_industry, days))
# 建立每只股票所属的行业全集字典
sectors = dict()
sizes = np.random.randint(low = 1, high = 4, size = num_stock)
for i in range(num_stock):
    sectors[i] = np.random.randint(low = 0, high = num_industry, size = sizes[i])

# 1.2 凸优化求解
betas1 = []
for i in range(num_stock):
    ind_idx = sectors[i] # 获取当前股票所属的行业全集
    num_ind = ind_idx.shape[0]
    beta = cp.Variable(shape = num_ind, name = "beta")                                          # 设置凸优化的变量
    objective1 = cp.Minimize(cp.sum((stock_return[i] - beta@industry_return[ind_idx])**2))   # 设置凸优化的目标
    constraints1 = [cp.sum(beta) == 1, beta >= 0]                                                           # 设置凸优化的约束条件
    problem1 = cp.Problem(objective1, constraints1)
    result1 = problem1.solve()    # 求解
    betas1.append(beta.value)    # 将求得的解存储

# 1.3 结果打印
print("%-9s\t%-20s\t%-40s"%("Stock", "Industries", "Betas"))
for i in range(num_stock):
    ind_idx = sectors[i]
    print("%-9d\t%-20s\t%-40s"%(i, repr(list(ind_idx)), np.array_repr(np.round(betas1[i], decimals=4))))


# 2. 第2问
# 2.1 生成数据，可以发现并不需要生成新数据，使用第一问的数据即可，只需要假装不知道每个行业的回报就好了

# 2.2 EM算法设置参数
num_iterations = 1000   # 最大迭代次数
delta = 1/2*1e-4        # 设置误差阈值，误差小于delta则认为收敛成功

# 2.3 EM算法
# 初始化
betas2 = []
beta_matrix = np.zeros((num_stock, num_industry))
for i in range(num_stock):
    ind_idx = sectors[i]
    num_ind = ind_idx.shape[0]
    betas2.append(np.ones(num_ind)/num_ind)
    beta_matrix[i, ind_idx] = betas2[i]
error = 1
# EM算法
for iter in range(num_iterations):
    # E-step
    ind_return = cp.Variable(shape = (num_industry, days), name = "industry_return")
    constraints2 = []
    objective2 = cp.Minimize(cp.sum((stock_return - beta_matrix@ind_return)**2))
    problem = cp.Problem(objective2, constraints2)
    result = problem.solve()
    ind_return.value
    # M-step
    betas2 = []
    new_beta_matrix = np.zeros((num_stock, num_industry))
    ind_return = ind_return.value
    for i in range(num_stock):
        ind_idx = sectors[i]
        num_ind = ind_idx.shape[0]
        beta = cp.Variable(shape = num_ind, name = "beta")
        objective2 = cp.Minimize(cp.sum((stock_return[i] - beta@ind_return[ind_idx])**2))
        constraints2 = [cp.sum(beta) == 1, beta >= 0]
        problem2 = cp.Problem(objective2, constraints2)
        result2 = problem2.solve()
        betas2.append(beta.value)
        new_beta_matrix[i, ind_idx] = betas2[i]
    error = np.sqrt(np.sum((new_beta_matrix - beta_matrix)**2))/num_stock
    beta_matrix = new_beta_matrix
    print("%d / %d, error = %f"%(iter+1, num_iterations, error))
    if(error < delta):
        print("收敛成功！")
        break

# 2.4 结果打印
print("%-9s\t%-20s\t%-40s"%("Stock", "Industries", "Betas"))
for i in range(num_stock):
    ind_idx = sectors[i]
    print("%-9d\t%-20s\t%-40s"%(i, repr(list(ind_idx)), np.array_repr(np.round(betas2[i], decimals=4))))
print("行业回报为：")
pd.DataFrame(np.round(ind_return, decimals=4))